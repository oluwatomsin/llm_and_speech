# Author: Amusa Abdulahi Tomisin
"""
This utils.py script is dedicated to all utilities needed withing our application
"""

import time
import logging


import os

log_file = 'logs/newfile.log'

# Check if the log file exists, if not create it
if not os.path.exists(log_file):
    with open(log_file, 'w') as f:
        f.write('')  # Create an empty log file

# Create and configure logger
logging.basicConfig(filename=log_file,
                    format='%(asctime)s - %(filename)s - %(message)s',
                    filemode='a')

logger = logging.getLogger()

# Setting the threshold of logger to DEBUG
logger.setLevel(logging.INFO)


def retry_on_failure(max_retries: int, delay: int = 1):
    """
    This function will server as a python decorator whenever we are connection to any server.
    This helps us make the function more robust so that our application only fails after a multiple
    attempt to connect to that server.
    :param max_retries: Number of times to retry connecting to the server
    :param delay: The delay time in seconds between attempts to reconnect.
    :return:
    """

    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(max_retries):
                try:
                    result = func(*args, **kwargs)
                    logger.info(f"Connected to server after {_} attempt(s)")
                    return result
                except Exception as e:
                    logger.debug(f"Error occurred while connecting:\n {e} \n Retrying...")
                    time.sleep(delay)
            logger.error("Connection to the server could not be established.")
            raise Exception("Maximum retries exceeded. Function failed")

        return wrapper

    return decorator


def save_to_memory(audio_name: str, chunk_size=1024):
    """
    This function will serve as a decorator for saving the audio generated by the endpoint to memory.
    :param audio_name: The name the audio should be saved as.
    :param chunk_size: the chunk of audio to be saved in a single batch.
    :return: the initial API response.
    """

    def decorator(func):
        def wrapper(*args, **kwargs):
            try:
                response = func(*args, **kwargs)
                with open(audio_name, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=chunk_size):
                        if chunk:
                            f.write(chunk)
                logger.info(f"Generated audio has been saved as {audio_name}.")
                return response
            except Exception as e:
                logger.error("Error occurred while saving generated audio to memory")
                raise e

        return wrapper

    return decorator
